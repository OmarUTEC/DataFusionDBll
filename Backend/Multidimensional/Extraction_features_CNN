'''
1. Leemos el csv con las libreria request y bytesIO
Descargamos las imágenes sin almacenarlas en el disco
2. Extracción de carácterísticas imágenes
3. Alamcenamos como vectores característicos
4. Guardamos en archivo binario: ID (int) + VECTOR(array flotante)

'''

import requests
from io import BytesIO
from tensorflow.keras.applications import InceptionV3
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.inception_v3 import preprocess_input
import numpy as np
import pandas as pd
import struct

file_path = "images1.csv"
data = pd.read_csv(file_path)

#Usamos modelo preentrenado
#no usamos capa fully commcected: false -> tranforma el modelo en un extractor
#usamos: GAP -> Tranforma tensor 2D en un vector de 2048
modelo = InceptionV3(weights='imagenet', include_top=False, pooling='avg')

def extrac_features_url(url):
    # solicitamos los datos de URL: get.url, la respuesta sera en formato binario
    response = requests.get(url)
    #bytes convierte en archivo para que load lo lea, ademas permite trabajar con datos en memoria sin tener que escribir en el disco
    img = image.load_img(BytesIO(response.content), target_size=(299,299))
    #imagen cargada a un array de numpy -> tridimensional 299,299,3
    img_array = image.img_to_array(img)

    # Asi sea una imagen, le agregamos 1 -> representará 1 lote de solo una imagen ya que los modelos preentrenados esperan recibir lotes de imagenes para procesarlos a la vez

    img_array = np.expand_dims(img_array, axis=0)
    #preprocesamos la imagen para que sea compatible con Inceptionv3
    #El preprocesamiento ajusta estos valores, asegurando que la imagen esté en el rango [-1, 1]
    img_array = preprocess_input(img_array)

    #Pasar la imagen preprocedaa a traves del modelo para extraer el vector
    features = modelo.predict(img_array)
    return features.flatten()


'''
for idx, row in data.iterrows():
    url = row['link']  # Enlace de la imagen
    filename = row['filename']  # Nombre del archivo de la imagen
    
    try:
        # Extraer el vector característico de la imagen
        features = extrac_features_url(url).flatten()  # Convertimos el tensor 2D en 1D
        
        # Imprimir el nombre de la imagen y el vector característico
        print(f"Características extraídas para {filename}:")
        print(features)  # Imprime el vector de características
        
    except Exception as e:
        print(f"Error procesando la imagen {filename}: {str(e)}")

print("Extracción completa.")
'''

def save_features_to_bin(filename, features,output):
    
      if len(features) != 2048:
        print(f"Error: el vector de características para el ID {id} no tiene 2048 dimensiones.")
        return  # Saltar esta imagen si no tiene el tamaño correcto
    
    # Empaquetar el ID (como entero) y los vectores de características (floats) en formato binario
    # Usamos 'i' para el ID entero y 'f' para los floats del vector de características
      with open(output, 'ab') as f:  # 'ab' es para agregar datos binarios
        # Empaquetar el ID y los vectores de características en el archivo binario
        f.write(struct.pack(f'i2048f', id, *features))


output_bin = 'Vector_images.bin'


for idx, row in data.iterrows():
    url = row['link']  # Enlace de la imagen
    id = idx  # Usar el índice de la iteración como el ID numérico en lugar del nombre del archivo
    
    try:
        # Extraer el vector característico de la imagen
        features = extrac_features_url(url)  # El vector ya está listo con 'features'
        
        # Guardar el ID de la imagen (numérico) y el vector característico en el archivo binario
        save_features_to_bin(id, features, output_bin)
        print(f"Características extraídas y guardadas para la imagen ID {id}")
    
    except Exception as e:
        print(f"Error procesando la imagen {id}: {str(e)}")

print(f"Extracción completa. Los vectores característicos se han guardado en {output_bin}")

